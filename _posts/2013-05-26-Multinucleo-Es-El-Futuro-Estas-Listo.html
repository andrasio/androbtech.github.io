---
layout: entrada
tags: ['Software', 'Concurrencia', 'Programación Orientada a Objetos']
title: ¡Multinúcleo es el futuro! ¿Estás listo?
---
<p>¿Estás preparado para lo que viene? ¿Qué estás mirando ahora? De una forma u otra la "revolución" vendrá y tienes que estar preparado. ¿Cuál es el desafío para computación? Es que tanto tienes para procesar por unidad de tiempo. El problema es poder. Podemos apreciar el incremento de órdenes de magnitud en los últimos 50 años en aspectos de poder computacional. Nuestra forma de usar programas -y varios a la vez-, ver videos con resolución perfecta, interactuar con más de diez personas en algún juego. Estas actividades eran imposible en aquellas épocas.</p>

<p>Todos estos beneficios se agradecen a la gente de Hardware. Son ellos los que a través de las décadas han logrado maravillas en la industria. Los amigos de Hardware siguieron desarrollando dándonos máquinas más pequeñas, baratas, rápidas. Prácticamente siguiendo la ley de Moore -cada 18 meses la tecnología se duplica-</p>

<h2>
¿Estás listo para beneficiar a los usuarios?</h2>

<p>La gente de Hardware llegó finalmente a una pared. Empezando el año 2000 en adelante la ley de Moore -el crecimiendo de tecnología cada 18 meses- llegó a los inicios de su fin (de cumplir). Desde ese momento los chips ya no serán más rápidos.</p>

<p>Es una realidad que los procesadores llegaron a un límite máximo de ciclos (Ghz). Los programadores podían despreocuparse si las aplicaciones llegaban al punto máximo de rendimiento debido que al poco tiempo saldrían nuevas computadoras más rápidas y por ende los programas automáticamente aprovecharan el rendimiento adquirido.</p>

<p>Surgieron nuevas computadoras con procesadores multinúcleos -cores-. Computadoras de 2 núcleos -Dual Core-, 4 núcleos -Quad Core-, 8 núcleos, 16, 32, 64, 1024, 2048 cláramente saben para donde va la cosa. </p>

<blockquote>
<p>Multinúcleo es el futuro.</p>
</blockquote>

<p>Si se desea programar para una ejecución rápida (algo que se ha hecho desde inicios de la industria) se tiene que programar para que la ejecución pueda ser compartida en cientos de procesadores, miles. Si deseamos que nuestros programas se beneficien a medida que se ejecuten en computadoras con más y más núcleos en ellas, necesitamos programar y pensar concurrentemente.</p>

<p>Sea si el programador crea una aplicación interactiva de escritorio, un servicio de alto rendimiento, concurrencia forma un papel importante si se desea aprovechar los beneficios de multinúcleos.</p>

<h2>¿Concurrencia, paralelismo?</h2>

<p>Se puede desarrollar programas con varios hilos de ejecución en una computadora de un núcleo así como también ejecutar el mismo programa con vários hilos en una computadora de vários núcleos. Dependiendo de qué interpretador se ejecutan los programas -generalmente una sola instancia de un interpretador como por ejemplo el JVM- se manifiestan las mismas preocupaciones. ¿Cómo controlas los hilos? ¿Cómo garantizas integridad de datos? ¿Cómo te manejas con cierres de exclusión mutua? ¿Sincronización?</p>

<p>En la industria no hay una distinción clara entre decir si es concurrencia o paralelismo. Las preocupaciones indicadas (así se denomine esto como concurrente o paralelo) son importantes para tener la garantía de que los programas ejecuten de forma eficiente y estén correctos.</p>

<h2>Beneficios de aprovechar concurrencia</h2>

<p>Puedo garantizar que la mayoría de aplicaciones que "los nuevos" desarrollan; desde el inicio el hilo principal de ejecución toma varias responsabilidades de forma secuencial. Quizá a través de la interacción con el usuario el programa extrae datos a través de un servicio web, actualiza la base de datos, sigue recibiendo peticiones del usuario, genera un cuadro de alerta sobre alguna notificación, sucesivamente. Estas tareas no siempre ocurren rápidamente, el programa quizá recopila información de varias páginas web en "tiempo real" y genera un reporte; estas tareas pueden tomar segundos, minutos. </p>

<p>¿Qué ocurre si una de las páginas que el programa analiza tiene mucho tráfico? El hilo principal de ejecución seguirá esperando respuesta de esa página. Mientras semejante situación ocurre el usuario no puede seguir usando el programa o cancelar la operación que toma tiempo porque el hilo principal está ocupado esperando respuesta de esa página.</p>

<p>La solución para esta situación en particular es crear un hilo adicional del cual su única responsabilidad sea extraer la información de la página web. El resultado es que el hilo principal delega la tarea de extraer la información al otro hilo de ejecución creado y puede felizmente seguir haciendo cualquier otra tarea (como recibir las acciones deseadas del usuario).</p>

<h2>La guerra de concurrencia</h2>

<p>Desafortunadamente el simple hecho de saber que hilos es la solución a dividir tareas no es suficiente, lejos. Es rara la situación para poder dividir un problema en partes isoladas y que también puedan ejecutarse de forma totalmente independiente entre ellas. Es más común computar operaciones de forma independiente pero siempre se llega al punto en que los resultados de esas operaciones tienen que recopilarse para tener un resultado deseado.</p>

<p>Basicamente los hilos se tienen que coordinar y es aquí donde surgen los problemas más comunes en el área de concurrencia. Esto es lo que lleva a guerras de sincronización y cierres de exclusión mutua. Las sorpresas que vienen debido a esto (solo comentaré de una) son:</p>

<ol>
<li>Inanición</li>
<li>Bloqueo mutuo</li>
<li>Condiciones de carrera.</li>
</ol>

<h2>Condiciones de carrera: El enemigo.</h2>

<p>Esto ocurre cuando dos hilos de ejecución compiten por el mismo dato o recurso. No necesariamente ocurre cuando dos hilos modifican datos, también puede ocurrir cuando un hilo está cambiando datos mientras que el otro intenta leer el dato. La condición de carrera puede provocar un comportamiento de un programa impredecible, una ejecución incorrecta por ende resultados que no son correctos.</p>

<p>Una de las soluciones es aplicar un cierre de exclusión mutua. La desventaja de usar este método de sincronización es el grado aplicado de granularidad y/o olvidar hacerlo. Es fácil usar esta forma de sincronizar -para programas muy cortos- pero la realidad es que los programas -el código- crece de manera abundante y es fácil perder el control.</p>

<h2>El verdadero problema</h2>

<p>El problema raíz de coordinación de hilos no es realmente la preocupación de no olvidar sincronizar sino la pelea con mutabilidad compartida.</p>

<p>Tengo la certeza de que actualmente el paradigma que gobierna ante el desarrollo de aplicaciones es programación orientada a objetos -Object Oriented Programming-. Tratar de modelar las cosas ante el mundo real de esta manera se hace más "fácil" el trabajo. Sin embargo, hay desventajas y una de esas es que por defecto podemos mutar fácilmente las instancias de nuestras clases.</p>

<p>La mayoría de los programadores están acostumbrados a programar pensando mutablemente. En lenguajes orientados a objetos se traduce a la creación y modificación del estado de un objeto -cambiar los campos-.</p>

<h2>¿Cómo puedes prepararte para el mundo multinúcleo?</h2>

<p>La solución para evitar problemas al coordinar hilos es la inmutabilidad. Programar pensando mutablemente no es malo tampoco pero en el mayor de los casos se usa mal lo cual puede llevar a problemas. </p>

<p>Cuando un programa está compuesto por objetos mutables, todo acceso a datos mutables compartidos tiene que ser verificado para estar correcto. Olvidar verificación así sea de un solo acceso, el programa está roto por definición. Solo tomaría la ejecución de una instrucción que involucre concurrencia para dañar todo.</p>

<blockquote>
<p>Mutabilidad compartida es una pesadilla, evítala.</p>
</blockquote>

<h2>¿Cómo podemos programar si no podemos cambiar nada?</h2>

<p>Se debe diseñar las aplicaciones aferrandose a inmutabilidad compartida. Entre las formas de atravesar el problema: </p>

<ol>
<li>Encapsular completamente la mutabilidad (lenguajes orientados a objetos son buenos para esto) y solo compartir datos inmutables.</li>
<li>Adherirse a inmutabilidad completa y aplicar funciones compuestas (lenguajes funcionales son perfectos para esto)</li>
<li>Usar una libreria que observa los cambios que hacemos e indicarnos de violaciones.</li>
</ol><p>¡Qúe esperas! ¡Ve a investigar en este momento si no estás listo!</p>
